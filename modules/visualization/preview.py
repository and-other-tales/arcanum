#!/usr/bin/env python3
"""
Texture and Model Preview Module
-----------------------------
This module provides visualization tools for previewing textures, atlases,
and 3D models generated by Arcanum.
"""

import os
import sys
import logging
import json
import numpy as np
import math
from typing import Dict, List, Any, Optional, Tuple, Union
from pathlib import Path
import tempfile
import time
import uuid
import shutil

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

# Try to import optional dependencies
try:
    from PIL import Image, ImageDraw, ImageFont
    PIL_AVAILABLE = True
except ImportError:
    logger.warning("PIL not available, some visualization features will be limited")
    PIL_AVAILABLE = False

try:
    import matplotlib.pyplot as plt
    from mpl_toolkits.mplot3d import Axes3D
    import matplotlib.patches as mpatches
    import matplotlib.colors as mcolors
    from matplotlib.collections import LineCollection
    MATPLOTLIB_AVAILABLE = True
except ImportError:
    logger.warning("Matplotlib not available, 3D visualization features will be limited")
    MATPLOTLIB_AVAILABLE = False

try:
    import trimesh
    TRIMESH_AVAILABLE = True
except ImportError:
    logger.warning("Trimesh not available, mesh visualization features will be limited")
    TRIMESH_AVAILABLE = False

class TextureVisualizer:
    """Provides visualization capabilities for textures, texture atlases, road networks, and coverage information."""

    def __init__(self, output_dir: str = None, font_path: str = None):
        """
        Initialize the texture visualizer.

        Args:
            output_dir: Directory to save visualizations
            font_path: Path to font file for adding labels
        """
        # Set default output directory
        if output_dir is None:
            output_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))),
                                     "visualizations")

        self.output_dir = Path(output_dir)
        os.makedirs(self.output_dir, exist_ok=True)

        # Font for labels
        self.font_path = font_path
        self.font = None

        # Try to load font
        if PIL_AVAILABLE:
            try:
                if font_path and os.path.exists(font_path):
                    self.font = ImageFont.truetype(font_path, 24)
                else:
                    # Try to use default font
                    self.font = ImageFont.load_default()
            except Exception as e:
                logger.warning(f"Failed to load font: {str(e)}")

        logger.info(f"TextureVisualizer initialized with output directory: {self.output_dir}")
    
    def generate_texture_preview(self, texture_path: str, output_path: str = None, 
                               label: str = None, scale: float = 1.0) -> Dict[str, Any]:
        """
        Generate a preview image for a texture.
        
        Args:
            texture_path: Path to the texture image
            output_path: Path to save the preview image, or None for default
            label: Optional label to add to the preview
            scale: Scale factor for the preview
            
        Returns:
            Dictionary with preview results
        """
        if not PIL_AVAILABLE:
            return {
                "success": False,
                "error": "PIL not available for texture visualization"
            }
        
        try:
            # Check if texture exists
            if not os.path.exists(texture_path):
                return {
                    "success": False,
                    "error": f"Texture file not found: {texture_path}"
                }
            
            # Set default output path if not provided
            if output_path is None:
                texture_name = os.path.basename(texture_path)
                output_path = os.path.join(self.output_dir, f"preview_{texture_name}")
            
            # Create output directory if needed
            os.makedirs(os.path.dirname(output_path), exist_ok=True)
            
            # Open and resize texture
            image = Image.open(texture_path)
            
            # Calculate new size if scaling
            if scale != 1.0:
                new_size = (int(image.width * scale), int(image.height * scale))
                image = image.resize(new_size, Image.Resampling.LANCZOS)
            
            # Add label if provided
            if label and self.font:
                draw = ImageDraw.Draw(image)
                
                # Add a background for the text
                text_width, text_height = draw.textbbox((0, 0), label, font=self.font)[2:4]
                draw.rectangle([(10, 10), (text_width + 20, text_height + 20)], fill=(0, 0, 0, 128))
                
                # Draw text
                draw.text((15, 15), label, font=self.font, fill=(255, 255, 255))
            
            # Save the preview
            image.save(output_path)
            
            logger.info(f"Generated texture preview at {output_path}")
            
            return {
                "success": True,
                "preview_path": output_path,
                "width": image.width,
                "height": image.height
            }
            
        except Exception as e:
            logger.error(f"Error generating texture preview: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }
    
    def generate_atlas_preview(self, atlas_path: str, mapping_data: Dict[str, Any],
                             output_path: str = None, show_grid: bool = True) -> Dict[str, Any]:
        """
        Generate a preview of a texture atlas with regions highlighted.
        
        Args:
            atlas_path: Path to the texture atlas image
            mapping_data: Dictionary mapping regions to UV coordinates
            output_path: Path to save the preview image, or None for default
            show_grid: Whether to show a grid overlay
            
        Returns:
            Dictionary with preview results
        """
        if not PIL_AVAILABLE:
            return {
                "success": False,
                "error": "PIL not available for atlas visualization"
            }
        
        try:
            # Check if atlas exists
            if not os.path.exists(atlas_path):
                return {
                    "success": False,
                    "error": f"Atlas file not found: {atlas_path}"
                }
            
            # Set default output path if not provided
            if output_path is None:
                atlas_name = os.path.basename(atlas_path)
                output_path = os.path.join(self.output_dir, f"atlas_preview_{atlas_name}")
            
            # Create output directory if needed
            os.makedirs(os.path.dirname(output_path), exist_ok=True)
            
            # Open atlas
            atlas = Image.open(atlas_path)
            
            # Create a copy for the preview
            preview = atlas.copy()
            draw = ImageDraw.Draw(preview)
            
            # Draw grid if requested
            if show_grid:
                # Draw grid lines every 256 pixels
                grid_spacing = 256
                atlas_width, atlas_height = atlas.size
                
                # Draw horizontal lines
                for y in range(0, atlas_height, grid_spacing):
                    draw.line([(0, y), (atlas_width, y)], fill=(128, 128, 128, 128), width=1)
                
                # Draw vertical lines
                for x in range(0, atlas_width, grid_spacing):
                    draw.line([(x, 0), (x, atlas_height)], fill=(128, 128, 128, 128), width=1)
            
            # Draw building regions with labels
            colors = [
                (255, 0, 0, 128),  # Red
                (0, 255, 0, 128),  # Green
                (0, 0, 255, 128),  # Blue
                (255, 255, 0, 128),  # Yellow
                (255, 0, 255, 128),  # Magenta
                (0, 255, 255, 128),  # Cyan
            ]
            
            # Process mapping data
            building_count = 0
            for building_id, mapping in mapping_data.items():
                try:
                    # Check if building has UV mapping
                    if "uv_mapping" not in mapping:
                        continue
                    
                    # Get UV coordinates
                    uv_coords = mapping["uv_mapping"]
                    
                    # Convert UVs to pixel coordinates
                    atlas_width, atlas_height = atlas.size
                    pixels = []
                    for uv in uv_coords:
                        x = int(uv[0] * atlas_width)
                        y = int(uv[1] * atlas_height)
                        pixels.append((x, y))
                    
                    # Draw polygon for the building region
                    if pixels:
                        color = colors[building_count % len(colors)]
                        draw.polygon(pixels, outline=(255, 255, 255, 200), fill=color)
                        
                        # Calculate center point for label
                        center_x = sum(p[0] for p in pixels) // len(pixels)
                        center_y = sum(p[1] for p in pixels) // len(pixels)
                        
                        # Draw label if font available
                        if self.font:
                            # Add a background for the text
                            text_width, text_height = draw.textbbox((0, 0), building_id, font=self.font)[2:4]
                            draw.rectangle(
                                [(center_x - text_width//2 - 5, center_y - text_height//2 - 5), 
                                 (center_x + text_width//2 + 5, center_y + text_height//2 + 5)], 
                                fill=(0, 0, 0, 200)
                            )
                            
                            # Draw text
                            draw.text(
                                (center_x - text_width//2, center_y - text_height//2), 
                                building_id, 
                                font=self.font, 
                                fill=(255, 255, 255, 255)
                            )
                    
                    building_count += 1
                    
                except Exception as e:
                    logger.warning(f"Error processing building {building_id}: {str(e)}")
            
            # Save the preview
            preview.save(output_path)
            
            logger.info(f"Generated atlas preview at {output_path} with {building_count} building regions")
            
            return {
                "success": True,
                "preview_path": output_path,
                "building_count": building_count,
                "width": atlas.width,
                "height": atlas.height
            }
            
        except Exception as e:
            logger.error(f"Error generating atlas preview: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }
    
    def preview_texture_mapping(self, obj_path: str, texture_path: str, output_path: str = None) -> Dict[str, Any]:
        """
        Generate a preview of how a texture maps to a 3D model.
        
        Args:
            obj_path: Path to the OBJ model file
            texture_path: Path to the texture image
            output_path: Path to save the preview image, or None for default
            
        Returns:
            Dictionary with preview results
        """
        if not TRIMESH_AVAILABLE or not MATPLOTLIB_AVAILABLE:
            return {
                "success": False,
                "error": "Required libraries not available for texture mapping visualization"
            }
        
        try:
            # Check if files exist
            if not os.path.exists(obj_path):
                return {
                    "success": False,
                    "error": f"OBJ file not found: {obj_path}"
                }
            
            if not os.path.exists(texture_path):
                return {
                    "success": False,
                    "error": f"Texture file not found: {texture_path}"
                }
            
            # Set default output path if not provided
            if output_path is None:
                obj_name = os.path.basename(obj_path).split('.')[0]
                output_path = os.path.join(self.output_dir, f"texture_mapping_{obj_name}.png")
            
            # Create output directory if needed
            os.makedirs(os.path.dirname(output_path), exist_ok=True)
            
            # Load the mesh
            mesh = trimesh.load(obj_path)
            
            # Load the texture
            texture = Image.open(texture_path)
            
            # Create a figure for the preview
            fig = plt.figure(figsize=(12, 8))
            
            # Add mesh subplot
            ax1 = fig.add_subplot(121, projection='3d')
            ax1.set_title("3D Model")
            
            # Convert to trimesh for visualization
            verts = mesh.vertices
            faces = mesh.faces
            
            # Plot the mesh
            ax1.plot_trisurf(verts[:, 0], verts[:, 1], verts[:, 2], triangles=faces, alpha=0.8)
            
            # Add texture subplot
            ax2 = fig.add_subplot(122)
            ax2.set_title("Texture")
            ax2.imshow(np.asarray(texture))
            
            # Set axes properties
            ax1.set_xlabel('X')
            ax1.set_ylabel('Y')
            ax1.set_zlabel('Z')
            ax1.grid(False)
            
            ax2.axis('off')
            
            # Add overall title
            plt.suptitle(f"Texture Mapping Preview: {os.path.basename(obj_path)}", fontsize=16)
            
            # Save the figure
            plt.tight_layout()
            plt.savefig(output_path, dpi=150, bbox_inches='tight')
            plt.close(fig)
            
            logger.info(f"Generated texture mapping preview at {output_path}")
            
            return {
                "success": True,
                "preview_path": output_path
            }
            
        except Exception as e:
            logger.error(f"Error generating texture mapping preview: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }
    
    def generate_building_screenshots(self, obj_path: str, texture_path: str, 
                                    output_dir: str = None, angles: List[Tuple[float, float]] = None, 
                                    resolution: Tuple[int, int] = (800, 600)) -> Dict[str, Any]:
        """
        Generate screenshots of a 3D building from different angles.
        
        Args:
            obj_path: Path to the OBJ model file
            texture_path: Path to the texture image
            output_dir: Directory to save screenshots, or None for default
            angles: List of (azimuth, elevation) angle pairs
            resolution: Screenshot resolution
            
        Returns:
            Dictionary with screenshot results
        """
        if not TRIMESH_AVAILABLE:
            return {
                "success": False,
                "error": "Trimesh not available for 3D visualization"
            }
        
        try:
            # Check if file exists
            if not os.path.exists(obj_path):
                return {
                    "success": False,
                    "error": f"OBJ file not found: {obj_path}"
                }
            
            # Set default output directory if not provided
            if output_dir is None:
                obj_name = os.path.basename(obj_path).split('.')[0]
                output_dir = os.path.join(self.output_dir, f"{obj_name}_screenshots")
            
            # Create output directory
            os.makedirs(output_dir, exist_ok=True)
            
            # Set default angles if not provided
            if angles is None:
                angles = [
                    (0, 30),     # Front view
                    (90, 30),    # Right side
                    (180, 30),   # Back
                    (270, 30),   # Left side
                    (0, 70),     # Top-front
                    (0, 10)      # Bottom-front
                ]
            
            # Load the mesh
            mesh = trimesh.load(obj_path)
            
            # Create a scene with the mesh
            scene = trimesh.Scene(mesh)
            
            # Generate screenshots for each angle
            screenshot_paths = []
            for i, (azimuth, elevation) in enumerate(angles):
                # Set camera position
                scene.camera.resolution = resolution
                scene.camera.fov = 60
                
                # Rotate to the angle
                scene.camera_transform = trimesh.transformations.rotation_matrix(
                    math.radians(azimuth), [0, 0, 1]
                )
                
                # Adjust for elevation
                rotation = trimesh.transformations.rotation_matrix(
                    math.radians(elevation), [1, 0, 0]
                )
                scene.camera_transform = trimesh.transformations.concatenate_matrices(
                    scene.camera_transform, rotation
                )
                
                # Translate to view distance
                distance = max(mesh.extents) * 2.0
                translation = trimesh.transformations.translation_matrix([0, 0, distance])
                scene.camera_transform = trimesh.transformations.concatenate_matrices(
                    scene.camera_transform, translation
                )
                
                # Render the scene
                screenshot = scene.save_image(resolution=resolution)
                
                # Save the screenshot
                screenshot_path = os.path.join(output_dir, f"screenshot_{i}_a{azimuth}_e{elevation}.png")
                with open(screenshot_path, 'wb') as f:
                    f.write(screenshot)
                
                screenshot_paths.append(screenshot_path)
            
            logger.info(f"Generated {len(screenshot_paths)} screenshots in {output_dir}")
            
            return {
                "success": True,
                "screenshot_paths": screenshot_paths,
                "screenshot_count": len(screenshot_paths)
            }
            
        except Exception as e:
            logger.error(f"Error generating building screenshots: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }
    
    def visualize_road_network(self, road_network_data: Dict[str, Any],
                               output_path: str = None,
                               resolution: Tuple[int, int] = (1920, 1080),
                               show_nodes: bool = True,
                               edge_width: float = 1.0,
                               node_size: float = 5.0) -> Dict[str, Any]:
        """
        Generate a visualization of a road network.

        Args:
            road_network_data: Dictionary with road network nodes and edges
            output_path: Path to save the visualization, or None for default
            resolution: Image resolution
            show_nodes: Whether to show intersection nodes
            edge_width: Width of the road edges
            node_size: Size of the intersection nodes

        Returns:
            Dictionary with visualization results
        """
        if not MATPLOTLIB_AVAILABLE:
            return {
                "success": False,
                "error": "Matplotlib not available for road network visualization"
            }

        try:
            # Set default output path if not provided
            if output_path is None:
                timestamp = int(time.time())
                output_path = os.path.join(self.output_dir, f"road_network_{timestamp}.png")

            # Create output directory if needed
            os.makedirs(os.path.dirname(output_path), exist_ok=True)

            # Create a figure for the visualization
            fig = plt.figure(figsize=(resolution[0]/100, resolution[1]/100), dpi=100)
            ax = fig.add_subplot(111)

            # Track bounds for centering
            min_x, min_y = float('inf'), float('inf')
            max_x, max_y = float('-inf'), float('-inf')

            # Extract nodes and edges from the road network data
            nodes = road_network_data.get("nodes", {})
            edges = road_network_data.get("edges", [])

            # Plot the network
            if not edges and not nodes:
                logger.warning("No road network data found to visualize")
                return {
                    "success": False,
                    "error": "No road network data found to visualize"
                }

            # Collect all lines for the LineCollection
            lines = []
            edge_types = {}  # To track different road types

            # Process edges to create lines
            for edge_id, edge in enumerate(edges):
                start_node_id = edge.get("start_node_id")
                end_node_id = edge.get("end_node_id")

                # Skip if missing node references
                if not start_node_id or not end_node_id:
                    continue

                # Get node coordinates
                start_node = nodes.get(start_node_id)
                end_node = nodes.get(end_node_id)

                # Skip if nodes don't exist
                if not start_node or not end_node:
                    continue

                start_x, start_y = start_node.get("x", 0), start_node.get("y", 0)
                end_x, end_y = end_node.get("x", 0), end_node.get("y", 0)

                # Update bounds
                min_x = min(min_x, start_x, end_x)
                min_y = min(min_y, start_y, end_y)
                max_x = max(max_x, start_x, end_x)
                max_y = max(max_y, start_y, end_y)

                # Add the line to the collection
                line = [(start_x, start_y), (end_x, end_y)]
                lines.append(line)

                # Track road type if available
                road_type = edge.get("type", "unknown")
                if road_type not in edge_types:
                    edge_types[road_type] = []
                edge_types[road_type].append(line)

            # Plot edges based on road type
            if edge_types:
                # Define colors for different road types
                road_colors = {
                    "motorway": "red",
                    "trunk": "orange",
                    "primary": "blue",
                    "secondary": "green",
                    "tertiary": "purple",
                    "residential": "gray",
                    "service": "lightgray",
                    "unknown": "black"
                }

                # Create a legend for road types
                legend_elements = []

                # Plot each road type with a different color
                for road_type, road_lines in edge_types.items():
                    color = road_colors.get(road_type, "black")
                    lc = LineCollection(road_lines, color=color, linewidth=edge_width, alpha=0.8)
                    ax.add_collection(lc)

                    legend_elements.append(mpatches.Patch(color=color, label=road_type))
            else:
                # All edges with same style if no types
                lc = LineCollection(lines, color='black', linewidth=edge_width, alpha=0.8)
                ax.add_collection(lc)

            # Plot nodes if requested
            if show_nodes:
                node_x = []
                node_y = []

                for node_id, node in nodes.items():
                    node_x.append(node.get("x", 0))
                    node_y.append(node.get("y", 0))

                ax.scatter(node_x, node_y, color='blue', s=node_size, alpha=0.7, zorder=2)

            # Set plot limits with a margin
            margin = 0.1  # 10% margin
            x_range = max_x - min_x
            y_range = max_y - min_y
            ax.set_xlim(min_x - margin * x_range, max_x + margin * x_range)
            ax.set_ylim(min_y - margin * y_range, max_y + margin * y_range)

            # Set equal aspect ratio
            ax.set_aspect('equal')

            # Add title and labels
            ax.set_title(f"Road Network: {len(edges)} Roads, {len(nodes)} Intersections")
            ax.set_xlabel("X Coordinate")
            ax.set_ylabel("Y Coordinate")

            # Add legend if we have road types
            if edge_types:
                ax.legend(handles=legend_elements, loc='upper right')

            # Add grid
            ax.grid(True, alpha=0.3)

            # Save the figure
            plt.tight_layout()
            plt.savefig(output_path, dpi=100, bbox_inches='tight')
            plt.close(fig)

            logger.info(f"Generated road network visualization at {output_path} with {len(edges)} roads and {len(nodes)} intersections")

            return {
                "success": True,
                "visualization_path": output_path,
                "edge_count": len(edges),
                "node_count": len(nodes),
                "bounds": {
                    "min_x": min_x,
                    "min_y": min_y,
                    "max_x": max_x,
                    "max_y": max_y
                }
            }

        except Exception as e:
            logger.error(f"Error generating road network visualization: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    def visualize_street_view_coverage(self, road_network_data: Dict[str, Any],
                                     coverage_data: List[Dict[str, Any]],
                                     output_path: str = None,
                                     resolution: Tuple[int, int] = (1920, 1080),
                                     point_size: float = 8.0) -> Dict[str, Any]:
        """
        Visualize Street View coverage over a road network.

        Args:
            road_network_data: Dictionary with road network nodes and edges
            coverage_data: List of Street View points with coordinates and metadata
            output_path: Path to save the visualization, or None for default
            resolution: Image resolution
            point_size: Size of the Street View points

        Returns:
            Dictionary with visualization results
        """
        if not MATPLOTLIB_AVAILABLE:
            return {
                "success": False,
                "error": "Matplotlib not available for coverage visualization"
            }

        try:
            # Set default output path if not provided
            if output_path is None:
                timestamp = int(time.time())
                output_path = os.path.join(self.output_dir, f"street_view_coverage_{timestamp}.png")

            # Create output directory if needed
            os.makedirs(os.path.dirname(output_path), exist_ok=True)

            # Create a figure for the visualization
            fig = plt.figure(figsize=(resolution[0]/100, resolution[1]/100), dpi=100)
            ax = fig.add_subplot(111)

            # Track bounds for centering
            min_x, min_y = float('inf'), float('inf')
            max_x, max_y = float('-inf'), float('-inf')

            # Extract nodes and edges from the road network data
            nodes = road_network_data.get("nodes", {})
            edges = road_network_data.get("edges", [])

            # Plot the road network as background
            lines = []

            # Process edges to create lines
            for edge_id, edge in enumerate(edges):
                start_node_id = edge.get("start_node_id")
                end_node_id = edge.get("end_node_id")

                # Skip if missing node references
                if not start_node_id or not end_node_id:
                    continue

                # Get node coordinates
                start_node = nodes.get(start_node_id)
                end_node = nodes.get(end_node_id)

                # Skip if nodes don't exist
                if not start_node or not end_node:
                    continue

                start_x, start_y = start_node.get("x", 0), start_node.get("y", 0)
                end_x, end_y = end_node.get("x", 0), end_node.get("y", 0)

                # Update bounds
                min_x = min(min_x, start_x, end_x)
                min_y = min(min_y, start_y, end_y)
                max_x = max(max_x, start_x, end_x)
                max_y = max(max_y, start_y, end_y)

                # Add the line to the collection
                line = [(start_x, start_y), (end_x, end_y)]
                lines.append(line)

            # Draw the road network in light gray as background
            if lines:
                lc = LineCollection(lines, color='lightgray', linewidth=1.0, alpha=0.5)
                ax.add_collection(lc)

            # Extract coverage data points
            coverage_x = []
            coverage_y = []
            coverage_status = []

            for point in coverage_data:
                x = point.get("x", 0)
                y = point.get("y", 0)
                status = point.get("status", "unknown")  # e.g., "success", "failed", "pending"

                coverage_x.append(x)
                coverage_y.append(y)
                coverage_status.append(status)

                # Update bounds
                min_x = min(min_x, x)
                min_y = min(min_y, y)
                max_x = max(max_x, x)
                max_y = max(max_y, y)

            # Define colors for different status types
            status_colors = {
                "success": "green",
                "failed": "red",
                "pending": "orange",
                "unknown": "blue"
            }

            # Create scatter plots for each status type
            for status in set(coverage_status):
                # Filter points by status
                x_points = [coverage_x[i] for i in range(len(coverage_x)) if coverage_status[i] == status]
                y_points = [coverage_y[i] for i in range(len(coverage_y)) if coverage_status[i] == status]

                if x_points:
                    color = status_colors.get(status, "blue")
                    ax.scatter(x_points, y_points, color=color, s=point_size,
                               alpha=0.8, label=f"{status.capitalize()} ({len(x_points)})")

            # Set plot limits with a margin
            margin = 0.1  # 10% margin
            x_range = max_x - min_x
            y_range = max_y - min_y
            ax.set_xlim(min_x - margin * x_range, max_x + margin * x_range)
            ax.set_ylim(min_y - margin * y_range, max_y + margin * y_range)

            # Set equal aspect ratio
            ax.set_aspect('equal')

            # Add title and labels
            ax.set_title(f"Street View Coverage: {len(coverage_data)} Points")
            ax.set_xlabel("X Coordinate")
            ax.set_ylabel("Y Coordinate")

            # Add legend
            ax.legend(loc='upper right')

            # Add grid
            ax.grid(True, alpha=0.3)

            # Save the figure
            plt.tight_layout()
            plt.savefig(output_path, dpi=100, bbox_inches='tight')
            plt.close(fig)

            logger.info(f"Generated Street View coverage visualization at {output_path} with {len(coverage_data)} points")

            return {
                "success": True,
                "visualization_path": output_path,
                "coverage_point_count": len(coverage_data),
                "bounds": {
                    "min_x": min_x,
                    "min_y": min_y,
                    "max_x": max_x,
                    "max_y": max_y
                }
            }

        except Exception as e:
            logger.error(f"Error generating Street View coverage visualization: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    def generate_city_overview(self, buildings_data: Dict[str, Any],
                             output_path: str = None,
                             resolution: Tuple[int, int] = (1920, 1080)) -> Dict[str, Any]:
        """
        Generate an overview image of the city with building footprints.

        Args:
            buildings_data: Dictionary with building geometries and metadata
            output_path: Path to save the overview image, or None for default
            resolution: Image resolution

        Returns:
            Dictionary with overview results
        """
        if not PIL_AVAILABLE or not MATPLOTLIB_AVAILABLE:
            return {
                "success": False,
                "error": "Required libraries not available for city visualization"
            }

        try:
            # Set default output path if not provided
            if output_path is None:
                timestamp = int(time.time())
                output_path = os.path.join(self.output_dir, f"city_overview_{timestamp}.png")

            # Create output directory if needed
            os.makedirs(os.path.dirname(output_path), exist_ok=True)

            # Create a figure for the overview
            fig = plt.figure(figsize=(resolution[0]/100, resolution[1]/100), dpi=100)
            ax = fig.add_subplot(111)

            # Track bounds for centering
            min_x, min_y = float('inf'), float('inf')
            max_x, max_y = float('-inf'), float('-inf')

            # Plot each building
            building_count = 0
            for building_id, building_data in buildings_data.items():
                try:
                    # Get building geometry
                    geometry = building_data.get("geometry", [])

                    if not geometry:
                        continue

                    # Extract coordinates
                    coords = []
                    for point in geometry:
                        x, y = point[0], point[1]
                        coords.append((x, y))

                        # Track bounds
                        min_x = min(min_x, x)
                        min_y = min(min_y, y)
                        max_x = max(max_x, x)
                        max_y = max(max_y, y)

                    # Convert to numpy arrays for plotting
                    if coords:
                        xs, ys = zip(*coords)

                        # Add building footprint
                        color = plt.cm.tab10(building_count % 10)  # Cycle through colors
                        ax.fill(xs, ys, alpha=0.7, edgecolor='black', linewidth=1, color=color)

                        # Add building ID label at centroid
                        centroid_x = sum(xs) / len(xs)
                        centroid_y = sum(ys) / len(ys)
                        ax.text(centroid_x, centroid_y, building_id, ha='center', va='center', fontsize=8)

                        building_count += 1

                except Exception as e:
                    logger.warning(f"Error processing building {building_id}: {str(e)}")

            # Set plot limits with a margin
            margin = 0.1  # 10% margin
            x_range = max_x - min_x
            y_range = max_y - min_y
            ax.set_xlim(min_x - margin * x_range, max_x + margin * x_range)
            ax.set_ylim(min_y - margin * y_range, max_y + margin * y_range)

            # Set equal aspect ratio
            ax.set_aspect('equal')

            # Add title and labels
            ax.set_title(f"City Overview: {building_count} Buildings")
            ax.set_xlabel("X Coordinate")
            ax.set_ylabel("Y Coordinate")

            # Add grid
            ax.grid(True, alpha=0.3)

            # Save the figure
            plt.tight_layout()
            plt.savefig(output_path, dpi=100, bbox_inches='tight')
            plt.close(fig)

            logger.info(f"Generated city overview at {output_path} with {building_count} buildings")

            return {
                "success": True,
                "overview_path": output_path,
                "building_count": building_count,
                "bounds": {
                    "min_x": min_x,
                    "min_y": min_y,
                    "max_x": max_x,
                    "max_y": max_y
                }
            }

        except Exception as e:
            logger.error(f"Error generating city overview: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }


# Convenience functions for direct usage

_default_visualizer = None

def get_default_visualizer() -> TextureVisualizer:
    """Get or create the default texture visualizer."""
    global _default_visualizer
    if _default_visualizer is None:
        output_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))),
                                "visualizations")
        _default_visualizer = TextureVisualizer(output_dir)
    return _default_visualizer

def generate_texture_preview(texture_path: str, output_path: str = None, 
                           label: str = None, scale: float = 1.0) -> Dict[str, Any]:
    """
    Generate a preview image for a texture.
    
    Args:
        texture_path: Path to the texture image
        output_path: Path to save the preview image, or None for default
        label: Optional label to add to the preview
        scale: Scale factor for the preview
        
    Returns:
        Dictionary with preview results
    """
    visualizer = get_default_visualizer()
    return visualizer.generate_texture_preview(texture_path, output_path, label, scale)

def generate_atlas_preview(atlas_path: str, mapping_data: Dict[str, Any],
                         output_path: str = None, show_grid: bool = True) -> Dict[str, Any]:
    """
    Generate a preview of a texture atlas with regions highlighted.
    
    Args:
        atlas_path: Path to the texture atlas image
        mapping_data: Dictionary mapping regions to UV coordinates
        output_path: Path to save the preview image, or None for default
        show_grid: Whether to show a grid overlay
        
    Returns:
        Dictionary with preview results
    """
    visualizer = get_default_visualizer()
    return visualizer.generate_atlas_preview(atlas_path, mapping_data, output_path, show_grid)

def generate_building_preview(obj_path: str, texture_path: str, output_dir: str = None) -> Dict[str, Any]:
    """
    Generate screenshots of a 3D building from different angles.
    
    Args:
        obj_path: Path to the OBJ model file
        texture_path: Path to the texture image
        output_dir: Directory to save screenshots, or None for default
        
    Returns:
        Dictionary with screenshot results
    """
    visualizer = get_default_visualizer()
    return visualizer.generate_building_screenshots(obj_path, texture_path, output_dir)

def preview_texture_mapping(obj_path: str, texture_path: str, output_path: str = None) -> Dict[str, Any]:
    """
    Generate a preview of how a texture maps to a 3D model.
    
    Args:
        obj_path: Path to the OBJ model file
        texture_path: Path to the texture image
        output_path: Path to save the preview image, or None for default
        
    Returns:
        Dictionary with preview results
    """
    visualizer = get_default_visualizer()
    return visualizer.preview_texture_mapping(obj_path, texture_path, output_path)

def generate_city_preview(buildings_data: Dict[str, Any], output_path: str = None) -> Dict[str, Any]:
    """
    Generate an overview image of the city with building footprints.

    Args:
        buildings_data: Dictionary with building geometries and metadata
        output_path: Path to save the overview image, or None for default

    Returns:
        Dictionary with overview results
    """
    visualizer = get_default_visualizer()
    return visualizer.generate_city_overview(buildings_data, output_path)

def visualize_road_network(road_network_data: Dict[str, Any],
                         output_path: str = None,
                         show_nodes: bool = True,
                         edge_width: float = 1.0) -> Dict[str, Any]:
    """
    Generate a visualization of a road network.

    Args:
        road_network_data: Dictionary with road network nodes and edges
        output_path: Path to save the visualization, or None for default
        show_nodes: Whether to show intersection nodes
        edge_width: Width of the road edges

    Returns:
        Dictionary with visualization results
    """
    visualizer = get_default_visualizer()
    return visualizer.visualize_road_network(road_network_data, output_path, show_nodes=show_nodes, edge_width=edge_width)

def visualize_street_view_coverage(road_network_data: Dict[str, Any],
                                 coverage_data: List[Dict[str, Any]],
                                 output_path: str = None,
                                 point_size: float = 8.0) -> Dict[str, Any]:
    """
    Visualize Street View coverage over a road network.

    Args:
        road_network_data: Dictionary with road network nodes and edges
        coverage_data: List of Street View points with coordinates and metadata
        output_path: Path to save the visualization, or None for default
        point_size: Size of the Street View points

    Returns:
        Dictionary with visualization results
    """
    visualizer = get_default_visualizer()
    return visualizer.visualize_street_view_coverage(road_network_data, coverage_data, output_path, point_size=point_size)


# Run a simple demo if this module is run directly
if __name__ == "__main__":
    import argparse

    # Set up logging to console
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s [%(levelname)s] %(message)s",
        handlers=[logging.StreamHandler(sys.stdout)]
    )

    # Parse arguments
    parser = argparse.ArgumentParser(description="Arcanum Visualization Tools")
    parser.add_argument("--texture", help="Path to texture file to preview")
    parser.add_argument("--atlas", help="Path to texture atlas file to preview")
    parser.add_argument("--obj", help="Path to OBJ model file to preview")
    parser.add_argument("--mapping", help="Path to UV mapping JSON file")
    parser.add_argument("--buildings", help="Path to buildings metadata JSON file")
    parser.add_argument("--road-network", help="Path to road network JSON file")
    parser.add_argument("--coverage", help="Path to Street View coverage JSON file")
    parser.add_argument("--output", help="Path to save preview output")
    parser.add_argument("--show-nodes", action="store_true", help="Show intersection nodes in road network")
    args = parser.parse_args()

    # Create visualizer
    visualizer = TextureVisualizer()

    # Generate texture preview if requested
    if args.texture:
        print(f"Generating preview for texture: {args.texture}")
        result = visualizer.generate_texture_preview(
            args.texture,
            args.output,
            label=os.path.basename(args.texture)
        )

        if result["success"]:
            print(f"Texture preview generated at: {result['preview_path']}")
        else:
            print(f"Error generating texture preview: {result.get('error')}")

    # Generate atlas preview if requested
    if args.atlas and args.mapping:
        print(f"Generating preview for atlas: {args.atlas}")

        # Load mapping data
        try:
            with open(args.mapping, 'r') as f:
                mapping_data = json.load(f)

            result = visualizer.generate_atlas_preview(
                args.atlas,
                mapping_data,
                args.output
            )

            if result["success"]:
                print(f"Atlas preview generated at: {result['preview_path']} with {result['building_count']} buildings")
            else:
                print(f"Error generating atlas preview: {result.get('error')}")

        except Exception as e:
            print(f"Error loading mapping data: {str(e)}")

    # Generate building preview if requested
    if args.obj and args.texture:
        print(f"Generating preview for building model: {args.obj}")

        result = visualizer.preview_texture_mapping(
            args.obj,
            args.texture,
            args.output
        )

        if result["success"]:
            print(f"Building preview generated at: {result['preview_path']}")
        else:
            print(f"Error generating building preview: {result.get('error')}")

    # Generate city overview if requested
    if args.buildings:
        print(f"Generating city overview from: {args.buildings}")

        # Load buildings data
        try:
            with open(args.buildings, 'r') as f:
                buildings_data = json.load(f)

            result = visualizer.generate_city_overview(
                buildings_data,
                args.output
            )

            if result["success"]:
                print(f"City overview generated at: {result['overview_path']} with {result['building_count']} buildings")
            else:
                print(f"Error generating city overview: {result.get('error')}")

        except Exception as e:
            print(f"Error loading buildings data: {str(e)}")

    # Generate road network visualization if requested
    if args.road_network:
        print(f"Generating road network visualization from: {args.road_network}")

        # Load road network data
        try:
            with open(args.road_network, 'r') as f:
                road_network_data = json.load(f)

            result = visualizer.visualize_road_network(
                road_network_data,
                args.output,
                show_nodes=args.show_nodes
            )

            if result["success"]:
                print(f"Road network visualization generated at: {result['visualization_path']} with {result['edge_count']} roads and {result['node_count']} intersections")
            else:
                print(f"Error generating road network visualization: {result.get('error')}")

        except Exception as e:
            print(f"Error loading road network data: {str(e)}")

    # Generate Street View coverage visualization if requested
    if args.road_network and args.coverage:
        print(f"Generating Street View coverage visualization from: {args.coverage}")

        # Load road network and coverage data
        try:
            with open(args.road_network, 'r') as f:
                road_network_data = json.load(f)

            with open(args.coverage, 'r') as f:
                coverage_data = json.load(f)

            result = visualizer.visualize_street_view_coverage(
                road_network_data,
                coverage_data,
                args.output
            )

            if result["success"]:
                print(f"Street View coverage visualization generated at: {result['visualization_path']} with {result['coverage_point_count']} coverage points")
            else:
                print(f"Error generating Street View coverage visualization: {result.get('error')}")

        except Exception as e:
            print(f"Error loading coverage data: {str(e)}")